# Server-client architecture

Formally, we do pursue a client-server architecture. However, as described in
the [interface specification](../Interface.md), the clients are rather simple.
In fact, we will not provide the clients as part of this project but reuse
existing networking tools common for unixoid systems, namely `nc` and
alternatives.

The server will need to handle a small number of connections. We could easily
spawn a thread for each of those connections under the assumption that we'll not
encounter misuse. However, we choose to take the more modern approach and work
with asynchronous interfaces. Rather than designing such interfaces, we'll make
use of [tokio](https://tokio.rs/), which implies the use of asynchronous tasks
or coroutines, as they'd be called in languages other than rust. In the past, I
generally avoided coroutines in favour for explicit segmentation of work, but
the risk of working with a concept I don't have much practical experience with
should be manageable.


# Tasks

Ideally, we'll reduce the amount of communication between tasks as much as
possible. This is obviously greatly influenced by how the tasks are divided.
Granting each connection a single task may seem natural, but may actually not be
the best choice. However, we'll use this division as a working model and deviate
from it where appropriate.

The [interface specification](../Interface.md) describes screens, which
effectively correspond to phases of the game:

 * Lobby
 * Waiting for round
 * Round in progress


## Game control task

As all players will transition to the next phase together, phase boundaries are
necessary synchronization points. Also, all screens involve the display of
registered players, in most cases with their scores. This implies that the
player roster, including the scores, is also shared and that updates must be
broadcast in some way. Furthermore, roster and score updates are related to
some of the phase transitions. On the other hand, the logic for each phase and
details regarding what information is included in the score board differ greatly
between the different phases.

Therefore, we'll pursue a design with a single control task constructed from few
phase-specific functions, which will implement the logic for a given phase and
manage the roster. Each of those functions will receive, among other relevant
data, a mutable references of the roster, `Sender`s and `Reciever`s necessary
for communicating with connection tasks as well as the game control channel.

Each phase control function will receive updates from connection tasks via
channels and broadcast general game-state information. The `tokio::sync::watch`
channel will come in handy for the latter. In addition to game state updates,
the central task will broadcast the current phase or an end-of-game indication
in the form of a rust `enum` via a separate channel. These phase update messages
will also serve as the vehicle for transmitting preparation data as well as
senders and receivers to connection tasks. The variant for a round will include
the round's number.

Since we don't want to couple the phases too closely, phase and phase control
function will never interact with the phase update channel directly. It will be
the toplevel control function's responsibility to send these updates and the
connection task's toplevel function's responsibility to unpack perquisite data.

However, we still need to communicate phase transitions to phase functions in
order for them to return control. We'll achieve this by using type erasure via a
trait which allows polling for transitions. For the sake of further decoupling,
or rather, allowing the use of non-public types, we'll also hide at least the
senders and receivers included with perquisite data behind types which will be
mainly opaque for parts of the software not dealing with a specific phase. Since
those structs are already strongly coupled to a specific phase, we may choose to
implement some of the connection task side of the logic as member functions of
those structs.

Using a direct channel for receiving updates from each connection would allow
identifying the sender simply via the identity of the `Receiver`, and make
detection of connection errors (or errors in connection tasks) particularly
simple. However, such a scheme would complicate the setup and probably cause
unreasonable overhead.

Instead, we decide for using an MPSC channel and explicitly tagging the updates
with the player with tags generated by a player handle we'll lease out to
connection tasks. In order to discard a player in the case of disconnects or
errors, we'll add an appropriate notification mechanism to the player handle and
have dropping the handle trigger such a notification.

### Lobby control function

The lobby phase is special in this regard, since in the beginning connection
tasks won't have any player information to tag updates. However, as new player
connections are only accepted during the lobby phase, we'll have the lobby
control function be responsible for accepting them, possibly via a sub-task, and
starting the associated connection tasks. This allows associating connections
with players by passing each connection task a token which is used during the
registration process.

The registration for a player will be performed via a MPSC channel transporting
the player name, connection token and a one-shot channel for the communication of
success or failure of the registration. In the case of a successful registration,
we include a handle to use for tagging updates in later phases. Thus, the item
type for the game state update channel is

    list of player names

while the item type for the registration channel is

    (player name, connection token, oneshot response channel)

and the item type for the response channel is

    success(player handle) | failure

Upon registration, the player name and connection task handle will be added to
the roster. The item type of the game control channel deviates from the item
type of the other phase control functions:

    registration acceptance |
    maximum number of players |
    game start(regular game control receiver)

### Waiting control function

During the waiting phase, we need to handle a timer for the countdown and
collect readiness indications from players. We'll broadcast the roster with the
current overall scores and an indication of the players' readiness, resulting in
the following item type for the game state update channel:

    (list of (player name, overall score, readyness), countdown value)

with "readiness" also indicating whether a player is still connected.

The readiness channel's item type will simply be

    player tag

The waiting control task will start the round control task, passing it the
required `Sender` and `Receiver` as well as roster with the overall score.

### Round preparation

As described in the [gameplay specification](../Gameplay.md), the order of
capsule element colours should be random but identical for all players. One
elegant possibility to achieve this would be using deterministic PRNGs which are
seeded with the same value. That seed also needs to be generated. We decided to
use the [rand_pcg](https://crates.io/crates/rand_pcg) library, which provides
PRNG implementation as well as utilities for retrieving entropy from the OS via
its `rand_core` dependency. Retrieving the entropy and preparing the field will
be the responsibility of the main game control task, i.e. they are outside the
scope of this function.

A new round will require a bit of preparation, namely the preparation of a new
field with viruses, which should be delegated to a sub-task for better
utilization and less waiting time.

### Round control function

Most of the actual game logic will be contained in the connection tasks. The
round control function's responsibilities are:

 * Updating and broadcasting the round scores,
 * Declaring the winner of a round and
 * Distributing unbound capsule elements sent by a player.

The latter will affect only a single player. At the same time, we must ensure
no values are lost. Especially the need to preserve all values rules out using a
watch channel for this purpose. In fact, any kind of channel may be unsuitable
since we will never wait for the availability of a value. Rather, we'll use a
queuing data structure behind a mutex for each player. Handles for these will be
included in the perquisite data for the round, together with the prepared field,
tick duration and seeded PRNG.

The item type for the game state update channel will be

    (list of (player name, round score, overall score, player state),
    optional tag of winner)

with "player state" indicating whether a player is still present.

The channel for updates from the connections will have the following item type:

    (player tag, capsule elements | new score | defeat)

Before returning, the function will update the roster by adding the round
scores to the overall scores.


## Player connection tasks

As described above, we'll spawn one task for each player connection. Each task
will hold a `Receiver` for game phase updates, from which it may derive the
`Sender`s and `Receiver`s specific for the current phase as well as a handle for
detecting transitions.

As phase transitions are driven by the game phase updates, we won't need to
duplicate the transition logic from the game control task. And centralizing that
logic is one objective of the game control task. However, we'll split the logic
into phase-specific functions just as we split the logic among phase-specific
control functions in the central task. Each of those functions will take as
input the perquisite data.

The main task will be responsible for consuming (or rather discarding) all input
from the client not consumed by a phase function when transitioning from one
phase to another. Furthermore, phase functions must make sure to force
transmission of written content to the client after processing an event.

### Lobby phase function

This function will receive as parameters the `Sender` and `Receiver` for the
phase as well as the connection token. It will return the (optional) handle for
the registered player.

The phase function will receive roster updates from the game control task,
which it will translate into displayable content and send to the client. It will
also receive input from the client: the characters for the player name as well
as registration commands in the form of control characters. The function will
update a local copy of the name, echoing updates to the client and issue a
registration on behalf of the player if requested. In the case of a successful
registration, all further input will be ignored. In the case of registration
failure, the name will not be cleared but an appropriate message will be sent
to the client.

### Waiting phase function

This function will receive as parameters the `Sender` and `Receiver` for the
phase as well as a reference to the player handle.

The phase function will receive updates of the roster and the countdown value
from the game control task, which it will render and send to the client. It will
also listen for input from the client. If any of the characters defined in the
specification is received, it will indicate readiness to the game control task
and ignore any further input.

### Round phase function

This function will receive as parameters the `Sender` and `Receiver` for the
phase, the prepared field, tick duration and PRNG seed as well as a reference to
the player handle.

This is undoubtedly the most complex of the phase functions. It receives roster
updates as well as unbound capsule elements from the game control task as well
as control input from the client. It renders the scoreboard and implements the
actual game logic concerning the field using the utilities defined in the
[gameplay implementation design](Gameplay.md).

### Round end display function

The termination message of a round phase will also contain a final score board
as well as a tag for the winner. This function will receive those as well as a
reference to the player handle as parameters and render an end-card indicating
whether the player has won or not.

The connection task will call this function before calling the waiting phase
function again.

### Connection termination

In addition to client-side termination of the connection and network errors, the
specification declares a client-side request for closing the connection via a
control character. Rather than implementing this logic in the various phase
specific functions, we'll use an abstraction on top of the connection, which
will close the connection on behalf of the client.

The connection will also be closed if the waiting phase ended without successful
player registration or if a phase function returns an end of game indication. In
the case of a closed connection, the task will terminate.


## Game master console tasks

One task will be responsible for accepting connections to the console socket via
an optional UNIX domain socket and spawning game consoles. In addition, this
task will listen for `SIGUSR1`, upon which it will initiate the game start.

Each console task will receive a handle through which it may pull a `Sender` for
issuing commands as well as the `Receiver` for phase updates. Furthermore it
will access the global game settings as well as the roster.

All game console tasks, as well as the central game console task, will terminate
if receiving an "end of game" indication via the phase update channel or if the
channel's writing end closes.

