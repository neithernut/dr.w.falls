# Server-client architecture

Formally, we do pursue a client-server architecture. However, as described in
the [interface specification](../Interface.md), the clients are rather simple.
In fact, we will not provide the clients as part of this project but reuse
existing networking tools common for unixoid systems, namely `nc` and
alternatives.

The server will need to handle a small number of connections. We could easily
spawn a thread for each of those connections under the assumption that we'll not
encounter misuse. However, we choose to take the more modern approach and work
with asynchronous interfaces. Rather than designing such interfaces, we'll make
use of [tokio](https://tokio.rs/), which implies the use of asynchronous tasks
or coroutines, as they'd be called in languages other than rust. In the past, I
generally avoided coroutines in favour for explicit segmentation of work, but
the risk of working with a concept I don't have much practical experience with
should be manageable.


# Tasks

Ideally, we'll reduce the amount of communication between tasks as much as
possible. This is obviously greatly influenced by how the tasks are divided.
Granting each connection a single task may seem natural, but may actually not be
the best choice. However, we'll use this division as a working model and deviate
from it where appropriate.

The [interface specification](../Interface.md) describes screens, which
effectively correspond to phases of the game:

 * Lobby
 * Waiting for round
 * Round in progress


## Game control task

As all players will transition to the next phase together, phase boundaries are
necessary synchronization points. Also, all screens involve the display of
registered players, in most cases with their scores. This implies that the
player roster, including the scores, is also shared and that updates must be
broadcast in some way. Furthermore, roster and score updates are related to
some of the phase transitions. On the other hand, the logic for each phase and
details regarding what information is included in the score board differ greatly
between the different phases.

Therefore, we'll pursue a design with a single control task constructed from few
phase-specific functions, which will implement the logic for a given phase and
manage the roster. Each of those functions will receive, among other relevant
data, a mutable references of the roster, `Sender`s and `Reciever`s necessary
for communicating with connection tasks as well as the game control channel.

Each phase control function will receive updates from connection tasks via
channels and broadcast general game-state information. The `tokio::sync::watch`
channel will come in handy for the latter. In addition to game state updates,
each broadcast channel used for sending messages from the control task to the
connection tasks will support a special transition message type as well as a
variant indicating end of game.

The transition message, which will be the last message sent via that channel in
most cases, will include `Sender`s for sending updates from connection tasks as
well as `Reciever`s for game state updates for the next phase. Since the message
must be received by all connection tasks, we cannot drop the previous `Sender`
before all those tasks had a chance to observe the state change. Hence, we'll
close the the `Sender`, possibly using the blocking `closed` function. This
implies that we need to drop old `Receiver`s in the connection task after
observing a transition message.

Since we don't want to couple the phases too closely, we'll use a generic
type for those senders and receivers, allowing us to inject the channel item
types for the next phase from the outside in a convenient and transparent
manner. The aforementioned transition message will hence not be sent by the
phase control function itself but the toplevel task, which will also close
the previous channel. This scheme will cause a circular dependency between the
message or item data types used for the waiting and round phases. However, this
should not be problematic since we'll declare all those specializations in a
single module anyway.

In addition, the task will broadcast a notification about the transition via a
phase update channel with the following item type:

    lobby | waiting | round(number) | end of game

Using a direct channel for receiving updates from each connection would allow
identifying the sender simply via the identity of the `Receiver`, and make
detection of connection errors (or errors in connection tasks) particularly
simple. However, such a scheme would complicate the setup and probably cause
unreasonable overhead.

Instead, we decide for using an MPSC channel and explicitly tagging the updates
with the player with tags generated by a player handle we'll lease out to
connection tasks. In order to discard a player in the case of disconnects or
errors, we'll add an appropriate notification mechanism to the player handle and
have dropping the handle trigger such a notification.

### Lobby control function

The lobby phase is special in this regard, since in the beginning connection
tasks won't have any player information to tag updates. However, as new player
connections are only accepted during the lobby phase, we'll have the lobby
control function be responsible for accepting them, possibly via a sub-task, and
starting the associated connection tasks. This allows associating connections
with players by passing each connection task a token which is used during the
registration process.

The registration for a player will be performed via a MPSC channel transporting
the player name, connection token and a one-shot channel for the communication of
success or failure of the registration. In the case of a successful registration,
we include a handle to use for tagging updates in later phases. Thus, the item
type for the game state update channel is

    list of player names | sender+receiver for the next phase | end of game

while the item type for the registration channel is

    (player name, connection token, oneshot response channel)

and the item type for the response channel is

    success(player handle) | failure

Upon registration, the player name and connection task handle will be added to
the roster. The item type of the game control channel deviates from the item
type of the other phase control functions:

    registration acceptance |
    maximum number of players |
    game start(regular game control receiver)

### Waiting control function

During the waiting phase, we need to handle a timer for the countdown and
collect readiness indications from players. We'll broadcast the roster with the
current overall scores and an indication of the player's readiness.

The round phase will require a bit of additional data which is described in the
following section in more detail, resulting in the following item type for the
game state update channel:

    (list of (player name, overall score, readyness), countdown value) |
    (sender+receiver for the next phase, prepared field, tick duration,
        seeded PRNG) |
    end of game

with "readiness" also indicating whether a player is still connected.

The readiness channel's item type will simply be

    player tag

The waiting control task will start the round control task, passing it the
required `Sender` and `Receiver` as well as roster with the overall score.

### Round preparation

As described in the [gameplay specification](../Gameplay.md), the order of
capsule element colours should be random but identical for all players. One
elegant possibility to achieve this would be using deterministic PRNGs which are
seeded with the same value. That seed also needs to be generated. We decided to
use the [rand_pcg](https://crates.io/crates/rand_pcg) library, which provides
PRNG implementation as well as utilities for retrieving entropy from the OS via
its `rand_core` dependency. Retrieving the entropy and preparing the field will
be the responsibility of the main game control task, i.e. they are outside the
scope of this function.

A new round will require a bit of preparation, namely the preparation of a new
field with viruses, which should be delegated to a sub-task for better
utilization and less waiting time.

### Round control function

Most of the actual game logic will be contained in the connection tasks. The
round control function's responsibilities are:

 * Updating and broadcasting the round scores,
 * Declaring the winner of a round and
 * Distributing unbound capsule elements sent by a player.

The latter will affect only a single player. At the same time, we must ensure
no values are lost. Especially the need to preserve all values rules out using a
watch channel for this purpose. Hence, we do make use of direct channels in this
instance. The `Receiver`s will be distributed via the score board.

The item type for the game state update channel will thus be

    list of (player name, round score, overall score, player state,
        capsule reciever) |
    (sender+receiver for the waiting phase, list of (player name, round score,
        overall score), tag of winner) |
    end of game

with "player state" indicating whether a player is still present and a capsule
receiver's item type of `capsule element unit`. The winner will be sent by the
task's top-level function. Hence, this function needs to communicate this
information via its return value.

The channel for updates from the connections will have the following item type:

    (player tag, capsule elements | new score)

Before returning, the function will update the roster by adding the round
scores to the overall scores.


## Player connection tasks

As described above, we'll spawn one task for each player connection. Each task
will hold a `Sender` and `Receiver` for the current phase. Upon receiving a
transition message, the task will assume the new `Sender` and `Receiver`,
replacing the old ones (i.e. those will be dropped).

As phase transitions are driven by those transition messages, we won't need to
duplicate the transition logic from the game control task. And centralizing that
logic is one objective of the game control task. However, we'll split the logic
into phase-specific functions just as we split the logic among phase-specific
control functions in the central task. Each of those functions will take as
input the contents of a transition message initiating the phase and return
either the contents of the contents of the transition message for the next phase
or an end of game indication. We'll decouple the phase-specific functions the
same way we do for the game control task.

The main task will be responsible for consuming (or rather discarding) all input
from the client not consumed by a phase function when transitioning from one
phase to another. Furthermore, phase functions must make sure to force
transmission of written content to the client after processing an event.

### Lobby phase function

This function will receive as parameters the `Sender` and `Receiver` for the
phase as well as the connection token. Besides the `Sender` and `Receiver` for
the waiting phase as part of the transition message, it will return the
(optional) handle for the registered player.

The phase function will receive roster updates from the game control task,
which it will translate into displayable content and send to the client. It will
also receive input from the client: the characters for the player name as well
as registration commands in the form of control characters. The function will
update a local copy of the name, echoing updates to the client and issue a
registration on behalf of the player if requested. In the case of a successful
registration, all further input will be ignored. In the case of registration
failure, the name will not be cleared but an appropriate message will be sent
to the client.

### Waiting phase function

This function will receive as parameters the `Sender` and `Receiver` for the
phase as well as a reference to the player handle. It will return the transition
message's content.

The phase function will receive updates of the roster and the countdown value
from the game control task, which it will render and send to the client. It will
also listen for input from the client. If any of the characters defined in the
specification is received, it will indicate readiness to the game control task
and ignore any further input.

### Round phase function

This function will receive as parameters the `Sender` and `Receiver` for the
phase, the prepared field, tick duration and PRNG seed as well as a reference to
the player handle. It will return the transition message's content.

This is undoubtedly the most complex of the phase functions. It receives roster
updates as well as unbound capsule elements from the game control task as well
as control input from the client. It renders the scoreboard and implements the
actual game logic concerning the field using the utilities defined in the
[gameplay implementation design](Gameplay.md).

### Round end display function

The termination message of a round phase will also contain a final score board
as well as a tag for the winner. This function will receive those as well as a
reference to the player handle as parameters and render an end-card indicating
whether the player has won or not.

The connection task will call this function before calling the waiting phase
function again.

### Connection termination

In addition to client-side termination of the connection and network errors, the
specification declares a client-side request for closing the connection via a
control character. Rather than implementing this logic in the various phase
specific functions, we'll use an abstraction on top of the connection, which
will close the connection on behalf of the client.

The connection will also be closed if the waiting phase ended without successful
player registration or if a phase function returns an end of game indication. In
the case of a closed connection, the task will terminate.


## Game master console task

A single game master console task is created for all consoles. It will receive
parsed lines from the various consoles, process them and send replies. It will
receive the `Sender` for the initial game control channel passed to the lobby
and the `Receiver` for phase updates. Furthermore it will access the global game
settings as well as the roster initialized by the lobby control task.

This task is also responsible for accepting connections from UNIX domain
sockets.

If this task receives an "end of game" indication via the phase update channel,
or if the channel's writing end closes, this task will terminate.

